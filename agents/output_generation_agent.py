"""
Output Generation Agent - Handles final document generation and export
"""
import os
import json
import zipfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from config.logging_config import get_logger
from config.settings import OUTPUT_DIR

try:
    import openpyxl
    from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
    EXCEL_AVAILABLE = True
except ImportError:
    EXCEL_AVAILABLE = False

logger = get_logger('output')

class OutputGenerationAgent:
    """Generates final output documents in various formats"""

    def __init__(self):
        self.logger = logger
        self.output_folder = OUTPUT_DIR
        self.output_folder.mkdir(exist_ok=True)
        
        # Supported output formats
        self.supported_formats = ['md', 'txt', 'json', 'html']
        if EXCEL_AVAILABLE:
            self.supported_formats.append('xlsx')

    def generate_markdown_output(self, content: str, filename: str) -> Dict[str, Any]:
        """Generate markdown output file"""
        result = {
            'success': False,
            'file_path': '',
            'file_size': 0,
            'errors': []
        }
        
        try:
            file_path = self.output_folder / f"{filename}.md"
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            result['success'] = True
            result['file_path'] = str(file_path)
            result['file_size'] = file_path.stat().st_size
            
            self.logger.info(f"Markdown file generated: {file_path}")
            
        except Exception as e:
            error_msg = f"Markdown generation failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def generate_html_output(self, content: str, filename: str) -> Dict[str, Any]:
        """Generate HTML output file with styling"""
        result = {
            'success': False,
            'file_path': '',
            'file_size': 0,
            'errors': []
        }
        
        try:
            # Convert markdown-like content to HTML
            html_content = self._markdown_to_html(content)
            
            # Wrap in complete HTML document
            full_html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Statement</title>
    <style>
        body {{
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }}
        h3 {{
            color: #7f8c8d;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }}
        tr:nth-child(even) {{
            background-color: #f8f9fa;
        }}
        .amount {{
            text-align: right;
            font-family: 'Courier New', monospace;
        }}
        .total {{
            font-weight: bold;
            background-color: #e8f4f8;
        }}
        .balance-check {{
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            font-weight: bold;
        }}
        .balanced {{
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }}
        .not-balanced {{
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }}
        .footer {{
            margin-top: 30px;
            text-align: center;
            color: #6c757d;
            font-size: 0.9em;
        }}
    </style>
</head>
<body>
    <div class="container">
        {html_content}
        <div class="footer">
            <p>Generated by Financial Statement Automation System</p>
            <p>Report Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        </div>
    </div>
</body>
</html>"""
            
            file_path = self.output_folder / f"{filename}.html"
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(full_html)
            
            result['success'] = True
            result['file_path'] = str(file_path)
            result['file_size'] = file_path.stat().st_size
            
            self.logger.info(f"HTML file generated: {file_path}")
            
        except Exception as e:
            error_msg = f"HTML generation failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def generate_excel_output(self, template_data: Dict[str, Any], filename: str) -> Dict[str, Any]:
        """Generate Excel output file"""
        result = {
            'success': False,
            'file_path': '',
            'file_size': 0,
            'errors': []
        }
        
        if not EXCEL_AVAILABLE:
            result['errors'].append("Excel generation not available - openpyxl not installed")
            return result
        
        try:
            file_path = self.output_folder / f"{filename}.xlsx"
            
            # Create workbook
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Financial Statement"
            
            # Styling
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="3498DB", end_color="3498DB", fill_type="solid")
            border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'), 
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )
            
            current_row = 1
            
            # Title
            ws.merge_cells(f'A{current_row}:D{current_row}')
            ws[f'A{current_row}'] = "Financial Statement Report"
            ws[f'A{current_row}'].font = Font(bold=True, size=16)
            ws[f'A{current_row}'].alignment = Alignment(horizontal='center')
            current_row += 2
            
            # Date
            ws[f'A{current_row}'] = f"Generated: {template_data.get('generation_date', 'N/A')}"
            current_row += 2
            
            # Summary section
            ws[f'A{current_row}'] = "Summary"
            ws[f'A{current_row}'].font = Font(bold=True, size=14)
            current_row += 1
            
            summary_items = [
                ("Total Accounts", template_data.get('total_accounts', 0)),
                ("Total Debits", f"${template_data.get('total_debits', 0):,.2f}"),
                ("Total Credits", f"${template_data.get('total_credits', 0):,.2f}"),
                ("Balance Difference", f"${template_data.get('balance_difference', 0):,.2f}"),
                ("Balance Status", "✓ Balanced" if template_data.get('balance_check', False) else "✗ Not Balanced")
            ]
            
            for item, value in summary_items:
                ws[f'A{current_row}'] = item
                ws[f'B{current_row}'] = value
                current_row += 1
            
            current_row += 2
            
            # Accounts details
            if 'accounts' in template_data and template_data['accounts']:
                ws[f'A{current_row}'] = "Account Details"
                ws[f'A{current_row}'].font = Font(bold=True, size=14)
                current_row += 1
                
                # Headers
                headers = ["Account Name", "Type", "Debit", "Credit"]
                for col, header in enumerate(headers, 1):
                    cell = ws.cell(row=current_row, column=col, value=header)
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.border = border
                
                current_row += 1
                
                # Account data
                for account in template_data['accounts']:
                    ws[f'A{current_row}'] = account.get('name', '')
                    ws[f'B{current_row}'] = account.get('type', '')
                    ws[f'C{current_row}'] = f"${account.get('debit', 0):,.2f}"
                    ws[f'D{current_row}'] = f"${account.get('credit', 0):,.2f}"
                    
                    # Apply borders
                    for col in range(1, 5):
                        ws.cell(row=current_row, column=col).border = border
                    
                    current_row += 1
                
                # Totals row
                ws[f'A{current_row}'] = "TOTALS"
                ws[f'A{current_row}'].font = Font(bold=True)
                ws[f'C{current_row}'] = f"${template_data.get('total_debits', 0):,.2f}"
                ws[f'C{current_row}'].font = Font(bold=True)
                ws[f'D{current_row}'] = f"${template_data.get('total_credits', 0):,.2f}"
                ws[f'D{current_row}'].font = Font(bold=True)
                
                for col in range(1, 5):
                    cell = ws.cell(row=current_row, column=col)
                    cell.border = border
                    cell.fill = PatternFill(start_color="E8F4F8", end_color="E8F4F8", fill_type="solid")
            
            # Auto-adjust column widths
            for column in ws.columns:
                max_length = 0
                column_letter = column[0].column_letter
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = min(max_length + 2, 50)
                ws.column_dimensions[column_letter].width = adjusted_width
            
            # Save workbook
            wb.save(file_path)
            wb.close()
            
            result['success'] = True
            result['file_path'] = str(file_path)
            result['file_size'] = file_path.stat().st_size
            
            self.logger.info(f"Excel file generated: {file_path}")
            
        except Exception as e:
            error_msg = f"Excel generation failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def generate_json_output(self, template_data: Dict[str, Any], filename: str) -> Dict[str, Any]:
        """Generate JSON output file"""
        result = {
            'success': False,
            'file_path': '',
            'file_size': 0,
            'errors': []
        }
        
        try:
            file_path = self.output_folder / f"{filename}.json"
            
            # Add metadata
            output_data = {
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'version': '1.0',
                    'format': 'financial_statement_json'
                },
                'financial_data': template_data
            }
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(output_data, f, indent=2, default=str)
            
            result['success'] = True
            result['file_path'] = str(file_path)
            result['file_size'] = file_path.stat().st_size
            
            self.logger.info(f"JSON file generated: {file_path}")
            
        except Exception as e:
            error_msg = f"JSON generation failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def create_output_package(self, base_filename: str, formats: List[str], content: str, template_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create a package with multiple output formats"""
        result = {
            'success': False,
            'package_path': '',
            'files_created': [],
            'errors': []
        }
        
        try:
            generated_files = []
            
            # Generate each requested format
            for format_type in formats:
                if format_type == 'md':
                    file_result = self.generate_markdown_output(content, base_filename)
                elif format_type == 'html':
                    file_result = self.generate_html_output(content, base_filename)
                elif format_type == 'xlsx' and EXCEL_AVAILABLE:
                    file_result = self.generate_excel_output(template_data, base_filename)
                elif format_type == 'json':
                    file_result = self.generate_json_output(template_data, base_filename)
                else:
                    continue
                
                if file_result['success']:
                    generated_files.append(file_result['file_path'])
                else:
                    result['errors'].extend(file_result['errors'])
            
            # Create ZIP package if multiple files
            if len(generated_files) > 1:
                package_path = self.output_folder / f"{base_filename}_package.zip"
                
                with zipfile.ZipFile(package_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in generated_files:
                        zipf.write(file_path, Path(file_path).name)
                
                result['package_path'] = str(package_path)
                self.logger.info(f"Output package created: {package_path}")
            
            result['success'] = True
            result['files_created'] = generated_files
            
        except Exception as e:
            error_msg = f"Package creation failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def _markdown_to_html(self, markdown_content: str) -> str:
        """Simple markdown to HTML conversion"""
        import re
        
        html = markdown_content
        
        # Headers

        html = re.sub(r'^# (.+)', r'<h1>\1</h1>', html, flags=re.MULTILINE)
        html = re.sub(r'^## (.+)', r'<h2>\1</h2>', html, flags=re.MULTILINE)
        html = re.sub(r'^### (.+)', r'<h3>\1</h3>', html, flags=re.MULTILINE)
        
        # Bold text
        html = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', html)
        
        # Tables - simple conversion
        lines = html.split('\n')
        in_table = False
        table_html = []
        
        for line in lines:
            if '|' in line and line.strip().startswith('|'):
                if not in_table:
                    table_html.append('<table>')
                    in_table = True
                
                cells = [cell.strip() for cell in line.split('|')[1:-1]]
                if all(cell.replace('-', '').strip() == '' for cell in cells):
                    continue  # Skip separator row
                
                if 'Account' in line or 'Item' in line:  # Header row
                    row_html = '<tr>'
                    for cell in cells:
                        row_html += f'<th>{cell}</th>'
                    row_html += '</tr>'
                else:  # Data row
                    row_html = '<tr>'
                    for i, cell in enumerate(cells):
                        class_attr = ' class="amount"' if '₹' in cell else ''

                        if '**' in cell:
                            cell = cell.replace('**', '')
                            class_attr += ' class="total"' if 'amount' in class_attr else ' class="total"'
                        row_html += f'<td{class_attr}>{cell}</td>'
                    row_html += '</tr>'
                
                table_html.append(row_html)
            else:
                if in_table:
                    table_html.append('</table>')
                    in_table = False
                table_html.append(line)
        
        if in_table:
            table_html.append('</table>')
        
        html = '\n'.join(table_html)
        
        # Balance check styling
        html = re.sub(r'✅ (.+)', r'<div class="balance-check balanced">✅ \1</div>', html)
        html = re.sub(r'❌ (.+)', r'<div class="balance-check not-balanced">❌ \1</div>', html)
        
        # Line breaks
        html = html.replace('\n\n', '<br><br>')
        html = html.replace('\n', '<br>')
        
        return html

    def cleanup_old_files(self, days_old: int = 7) -> Dict[str, Any]:
        """Clean up old output files"""
        result = {
            'files_deleted': 0,
            'space_freed': 0,
            'errors': []
        }
        
        try:
            from datetime import timedelta
            cutoff_date = datetime.now() - timedelta(days=days_old)
            
            for file_path in self.output_folder.iterdir():
                if file_path.is_file():
                    file_modified = datetime.fromtimestamp(file_path.stat().st_mtime)
                    if file_modified < cutoff_date:
                        file_size = file_path.stat().st_size
                        file_path.unlink()
                        result['files_deleted'] += 1
                        result['space_freed'] += file_size
            
            self.logger.info(f"Cleanup completed: {result['files_deleted']} files deleted, {result['space_freed']} bytes freed")
            
        except Exception as e:
            error_msg = f"Cleanup failed: {e}"
            result['errors'].append(error_msg)
            self.logger.error(error_msg)
        
        return result

    def get_output_stats(self) -> Dict[str, Any]:
        """Get output directory statistics"""
        stats = {
            'total_files': 0,
            'total_size': 0,
            'file_types': {},
            'recent_files': []
        }
        
        try:
            if self.output_folder.exists():
                for file_path in self.output_folder.iterdir():
                    if file_path.is_file():
                        stats['total_files'] += 1
                        file_size = file_path.stat().st_size
                        stats['total_size'] += file_size
                        
                        # Count by extension
                        ext = file_path.suffix.lower()
                        stats['file_types'][ext] = stats['file_types'].get(ext, 0) + 1
                        
                        # Recent files (last 24 hours)
                        file_modified = datetime.fromtimestamp(file_path.stat().st_mtime)
                        if (datetime.now() - file_modified).days == 0:
                            stats['recent_files'].append({
                                'name': file_path.name,
                                'size': file_size,
                                'modified': file_modified.isoformat()
                            })
            
        except Exception as e:
            self.logger.error(f"Stats collection failed: {e}")
        
        return stats